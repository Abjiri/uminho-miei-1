--
-- Table structure for table `actor`
--

CREATE TABLE actor (
  actor_id INTEGER GENERATED BY DEFAULT AS IDENTITY,
  first_name VARCHAR(45) NOT NULL,
  last_name VARCHAR(45) NOT NULL,
  last_update TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT actor_PK PRIMARY KEY (actor_id)
);

CREATE INDEX idx_actor_last_name ON actor (last_name);

CREATE OR REPLACE TRIGGER actor_timestamp_update
    BEFORE UPDATE ON actor
    FOR EACH ROW
    BEGIN
        :new.last_update := sysdate;
    END;

--
-- Table structure for table `country`
--

CREATE TABLE country (
  country_id INTEGER GENERATED BY DEFAULT AS IDENTITY,
  country VARCHAR(50) NOT NULL,
  last_update TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT country_PK PRIMARY KEY  (country_id)
);

CREATE OR REPLACE TRIGGER country_timestamp_update
    BEFORE UPDATE ON country
    FOR EACH ROW
    BEGIN
        :new.last_update := sysdate;
    END;

--
-- Table structure for table `city`
--

CREATE TABLE city (
  city_id INTEGER GENERATED BY DEFAULT AS IDENTITY,
  city VARCHAR(50) NOT NULL,
  country_id INTEGER NOT NULL,
  last_update TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT city_PK PRIMARY KEY (city_id),
  CONSTRAINT fk_city_country FOREIGN KEY (country_id) REFERENCES country (country_id)
  );

CREATE INDEX idx_fk_country_id ON city (country_id);

CREATE OR REPLACE TRIGGER city_timestamp_update
    BEFORE UPDATE ON city
    FOR EACH ROW
    BEGIN
        :new.last_update := sysdate;
    END;

--
-- Table structure for table `city`
--

CREATE TABLE address (
  address_id INTEGER GENERATED BY DEFAULT AS IDENTITY,
  address VARCHAR(50) NOT NULL,
  address2 VARCHAR(50) DEFAULT NULL,
  district VARCHAR(20) NOT NULL,
  city_id INTEGER NOT NULL,
  postal_code VARCHAR(10) DEFAULT NULL,
  phone VARCHAR(20) NOT NULL,
  last_update TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT adress_PK PRIMARY KEY  (address_id),
  CONSTRAINT fk_address_city FOREIGN KEY (city_id) REFERENCES city (city_id)
);

CREATE INDEX idx_fk_city_id ON address (city_id);

CREATE OR REPLACE TRIGGER address_timestamp_update
    BEFORE UPDATE ON address
    FOR EACH ROW
    BEGIN
        :new.last_update := sysdate;
    END;



--
-- Table structure for table `language`
--

CREATE TABLE language_t (
  language_id INTEGER GENERATED BY DEFAULT AS IDENTITY,
  l_name CHAR(20) NOT NULL,
  last_update TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT language_PK PRIMARY KEY (language_id)
);

CREATE OR REPLACE TRIGGER language_timestamp_update
    BEFORE UPDATE ON language_t
    FOR EACH ROW
    BEGIN
        :new.last_update := sysdate;
    END;

--
-- Table structure for table `film_text`
--

CREATE TABLE film_text (
  film_id INTEGER GENERATED BY DEFAULT AS IDENTITY,
  title VARCHAR(255) NOT NULL,
  description VARCHAR(255),
  CONSTRAINT film_PK PRIMARY KEY  (film_id)
);

--
-- Table structure for table `film`
--


CREATE TABLE film (
  film_id INTEGER GENERATED BY DEFAULT AS IDENTITY,
  title VARCHAR(255) NOT NULL,
  description  VARCHAR(255) DEFAULT NULL,
  release_year INTEGER DEFAULT NULL,
  language_id INTEGER NOT NULL,
  original_language_id INTEGER DEFAULT NULL,
  rental_duration INTEGER DEFAULT 3 NOT NULL,
  rental_rate DECIMAL(4,2) DEFAULT 4.99 NOT NULL,
  length INTEGER DEFAULT NULL,
  replacement_cost DECIMAL(5,2) DEFAULT 19.99 NOT NULL,
  rating VARCHAR(10) DEFAULT 'G',
  special_features VARCHAR(64) DEFAULT NULL,
  last_update TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT filmf_PK PRIMARY KEY  (film_id),
  CONSTRAINT fk_film_language FOREIGN KEY (language_id) REFERENCES language_t (language_id),
  CONSTRAINT fk_film_language_original FOREIGN KEY (original_language_id) REFERENCES language_t (language_id)
);


CREATE INDEX idx_title ON film (title);
CREATE INDEX idx_fk_language_id ON film (language_id);
CREATE INDEX idx_fk_original_language_id ON film (original_language_id);

CREATE OR REPLACE TRIGGER film_timestamp_update
    BEFORE UPDATE ON film
    FOR EACH ROW
    BEGIN
        :new.last_update := sysdate;
    END;

--
-- Table structure for table `film_actor`
--

CREATE TABLE film_actor (
  actor_id INTEGER NOT NULL,
  film_id INTEGER NOT NULL,
  last_update TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT film_actor_PK PRIMARY KEY  (actor_id,film_id),
  CONSTRAINT fk_film_actor_actor FOREIGN KEY (actor_id) REFERENCES actor (actor_id),
  CONSTRAINT fk_film_actor_film FOREIGN KEY (film_id) REFERENCES film (film_id)
);

CREATE INDEX idx_film_actor_title ON film_actor (film_id);

CREATE OR REPLACE TRIGGER film_actor_timestamp_update
    BEFORE UPDATE ON film_actor
    FOR EACH ROW
    BEGIN
        :new.last_update := sysdate;
    END;

--
-- Table structure for table `category`
--

CREATE TABLE category (
  category_id INTEGER GENERATED BY DEFAULT AS IDENTITY,
  name VARCHAR(25) NOT NULL,
  last_update TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT category_PK PRIMARY KEY  (category_id)
);

CREATE OR REPLACE TRIGGER category_timestamp_update
    BEFORE UPDATE ON category
    FOR EACH ROW
    BEGIN
        :new.last_update := sysdate;
    END;

--
-- Table structure for table `film_category`
--

CREATE TABLE film_category (
  film_id INTEGER NOT NULL,
  category_id INTEGER NOT NULL,
  last_update TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT film_categoru_PK PRIMARY KEY (film_id, category_id),
  CONSTRAINT fk_film_category_film FOREIGN KEY (film_id) REFERENCES film (film_id) ,
  CONSTRAINT fk_film_category_category FOREIGN KEY (category_id) REFERENCES category (category_id)
);

CREATE OR REPLACE TRIGGER film_category_timestamp_update
    BEFORE UPDATE ON film_category
    FOR EACH ROW
    BEGIN
        :new.last_update := sysdate;
    END;

--
-- Table structure for table `store`
--

CREATE TABLE store (
  store_id INTEGER GENERATED BY DEFAULT AS IDENTITY,
  manager_staff_id INTEGER NOT NULL,
  address_id INTEGER NOT NULL,
  last_update TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT store_PK PRIMARY KEY  (store_id),
  CONSTRAINT fk_store_address FOREIGN KEY (address_id) REFERENCES address (address_id)
);

CREATE UNIQUE INDEX idx_store_manager_staff_id ON store (manager_staff_id);
CREATE INDEX idx_store_address_id ON store (address_id);

CREATE OR REPLACE TRIGGER store_timestamp_trigger
    BEFORE UPDATE ON store
    FOR EACH ROW
    BEGIN
        :new.last_update := sysdate;
    END;

--
-- Table structure for table `staff`
--

CREATE TABLE staff ( 
  staff_id INTEGER GENERATED BY DEFAULT AS IDENTITY, 
  first_name VARCHAR(45) NOT NULL, 
  last_name VARCHAR(45) NOT NULL, 
  address_id INTEGER NOT NULL, 
  picture BLOB, 
  email VARCHAR(50) NOT NULL, 
  store_id INTEGER NOT NULL, 
  active NUMBER(1) NOT NULL, 
  username VARCHAR(16) NOT NULL, 
  password VARCHAR(40) NOT NULL, 
  last_update TIMESTAMP DEFAULT CURRENT_TIMESTAMP, 
  CONSTRAINT staff_PK PRIMARY KEY  (staff_id), 
  CONSTRAINT fk_staff_store FOREIGN KEY (store_id) REFERENCES store (store_id), 
  CONSTRAINT fk_staff_address FOREIGN KEY (address_id) REFERENCES address (address_id) 
);

CREATE INDEX idx_fk_store_id ON staff (store_id);
CREATE INDEX fk_staff_address ON staff (address_id);

CREATE OR REPLACE TRIGGER staff_timestamp_trigger
    BEFORE UPDATE ON staff
    FOR EACH ROW
    BEGIN
        :new.last_update := sysdate;
    END;

ALTER TABLE store
    ADD CONSTRAINT fk_store_staff FOREIGN KEY (manager_staff_id) REFERENCES staff (staff_id);

--
-- Table structure for table `customer`
--

CREATE TABLE customer (
  customer_id INTEGER GENERATED BY DEFAULT AS IDENTITY,
  store_id INTEGER NOT NULL,
  first_name VARCHAR(45) NOT NULL,
  last_name VARCHAR(45) NOT NULL,
  email VARCHAR(50) DEFAULT NULL,
  address_id INTEGER NOT NULL,
  active NUMBER(1) NOT NULL,
  create_date DATE NOT NULL,
  last_update TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT customer_PK PRIMARY KEY  (customer_id),
  CONSTRAINT fk_customer_address FOREIGN KEY (address_id) REFERENCES address (address_id),
  CONSTRAINT fk_customer_store FOREIGN KEY (store_id) REFERENCES store (store_id)
);

CREATE INDEX idx_fk_store_id_customer ON customer (store_id);
CREATE INDEX idx_fk_address_id ON customer (address_id);
CREATE INDEX idx_last_name ON customer (last_name);


CREATE OR REPLACE TRIGGER customer_timestamp_update
    BEFORE UPDATE ON customer
    FOR EACH ROW
    BEGIN
        :new.last_update := sysdate;
    END;

--
-- Table structure for table `inventory`
--

CREATE TABLE inventory (
  inventory_id INTEGER GENERATED BY DEFAULT AS IDENTITY,
  film_id INTEGER NOT NULL,
  store_id INTEGER NOT NULL,
  last_update TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT inventory_PK PRIMARY KEY  (inventory_id),
  CONSTRAINT fk_inventory_store FOREIGN KEY (store_id) REFERENCES store (store_id),
  CONSTRAINT fk_inventory_film FOREIGN KEY (film_id) REFERENCES film (film_id)
);

CREATE INDEX idx_fk_film_id ON inventory (film_id);
CREATE INDEX idx_store_id_film_id ON inventory (store_id,film_id);

CREATE OR REPLACE TRIGGER inventory_timestamp_update
    BEFORE UPDATE ON inventory
    FOR EACH ROW
    BEGIN
        :new.last_update := sysdate;
    END;

--
-- Table structure for table `rental`
--

CREATE TABLE rental (
  rental_id INTEGER GENERATED BY DEFAULT AS IDENTITY,
  rental_date DATE NOT NULL,
  inventory_id INTEGER NOT NULL,
  customer_id INTEGER NOT NULL,
  return_date DATE NULL,
  staff_id INTEGER NOT NULL,
  last_update TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT rental_PK PRIMARY KEY (rental_id),
  CONSTRAINT fk_rental_staff FOREIGN KEY (staff_id) REFERENCES staff (staff_id),
  CONSTRAINT fk_rental_inventory FOREIGN KEY (inventory_id) REFERENCES inventory (inventory_id),
  CONSTRAINT fk_rental_customer FOREIGN KEY (customer_id) REFERENCES customer (customer_id)
);

  CREATE INDEX idx_fk_inventory_id ON rental (inventory_id);
  CREATE INDEX idx_fk_customer_id ON rental(customer_id);
  CREATE INDEX idx_fk_staff_id ON rental (staff_id);

  CREATE OR REPLACE TRIGGER rental_timestamp_update
    BEFORE UPDATE ON rental
    FOR EACH ROW
    BEGIN
        :new.last_update := sysdate;
    END;

--
-- Table structure for table `payment`
--

CREATE TABLE payment (
  payment_id INTEGER GENERATED BY DEFAULT AS IDENTITY,
  customer_id INTEGER NOT NULL,
  staff_id INTEGER NOT NULL,
  rental_id INTEGER DEFAULT NULL,
  amount DECIMAL(5,2) NOT NULL,
  payment_date DATE NOT NULL,
  last_update TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT payment_PK PRIMARY KEY  (payment_id),
  CONSTRAINT fk_payment_rental FOREIGN KEY (rental_id) REFERENCES rental (rental_id),
  CONSTRAINT fk_payment_customer FOREIGN KEY (customer_id) REFERENCES customer (customer_id),
  CONSTRAINT fk_payment_staff FOREIGN KEY (staff_id) REFERENCES staff (staff_id)
 );

CREATE INDEX idx_fk_staff_payment_id ON payment (staff_id);
CREATE INDEX idx_fk_customer_payment_id ON payment (customer_id);

CREATE OR REPLACE TRIGGER payment_timestamp_update
    BEFORE UPDATE ON payment
    FOR EACH ROW
    BEGIN
        :new.last_update := sysdate;
    END;

-- View structure for view `sales_by_film_category`
CREATE VIEW sales_by_film_category AS
	SELECT
		c.name AS category,
		SUM(p.amount) AS total_sales
	FROM payment p
	INNER JOIN rental r ON (p.rental_id = r.rental_id)
	INNER JOIN inventory i ON (r.inventory_id = i.inventory_id)
	INNER JOIN film f ON (i.film_id = f.film_id)
	INNER JOIN film_category fc ON (f.film_id = fc.film_id)
	INNER JOIN category c ON (fc.category_id = c.category_id)
	GROUP BY c.name
	ORDER BY total_sales;

--
-- View structure for view `staff_list`
--
CREATE VIEW staff_list
AS
    SELECT s.staff_id AS ID, 
    (s.first_name || ' ' || s.last_name) AS name, 
    a.address AS address, 
    a.postal_code AS zip_code, 
    a.phone AS phone,
	city.city AS city, 
	country.country AS country, 
	s.store_id AS SID 
	FROM staff s 
    JOIN address  a ON (s.address_id = a.address_id)
    JOIN city ON (a.city_id = city.city_id)
    JOIN country ON (city.country_id = country.country_id);

--
-- View structure for view `customer_list`
--

CREATE VIEW customer_list
AS
SELECT cu.customer_id AS ID, 
(cu.first_name || ' ' || cu.last_name) AS name, 
a.address AS address, a.postal_code AS zip_code,
	a.phone AS phone, 
  city.city AS city, 
  country.country AS country, 
  cu.active AS notes, 
  cu.store_id AS SID
FROM customer cu JOIN address a ON cu.address_id = a.address_id JOIN city ON a.city_id = city.city_id
	JOIN country ON city.country_id = country.country_id;


--
-- Trigger to enforce create dates on INSERT
--
CREATE OR REPLACE TRIGGER customer_create_date
BEFORE INSERT ON customer
	FOR EACH ROW
  BEGIN 
    :new.create_date := sysdate;
END;

--
-- Trigger to enforce payment_date during INSERT
--
CREATE OR REPLACE TRIGGER payment_date
BEFORE INSERT ON payment
	FOR EACH ROW
  BEGIN 
    :new.payment_date := sysdate;
END;  

--
-- Trigger to enforce rental_date on INSERT
--
CREATE OR REPLACE TRIGGER rental_date
BEFORE INSERT ON rental
	FOR EACH ROW
  BEGIN 
    :new.rental_date := sysdate;
END;


--
-- Triggers for loading film_text from film
--
CREATE OR REPLACE TRIGGER ins_film
AFTER INSERT ON film
	FOR EACH ROW
  BEGIN 
    INSERT INTO film_text (film_id, title, description)
        VALUES (:new.film_id, :new.title, :new.description);
END;

CREATE OR REPLACE TRIGGER upd_film
AFTER UPDATE ON film
	FOR EACH ROW
  BEGIN 
    IF (:old.title != :new.title) OR (:old.description != :new.description) OR (:old.film_id != :new.film_id)
        THEN
            UPDATE film_text
                SET title = :new.title,
                    description = :new.description,
                    film_id = :new.film_id
            WHERE film_id = :old.film_id;
        END IF;
END;

CREATE OR REPLACE TRIGGER del_film
AFTER DELETE ON film
	FOR EACH ROW
  BEGIN 
    DELETE FROM film_text WHERE film_id = :old.film_id;
END;